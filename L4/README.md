# Балансировки

## Задание

1. Напиши простой сетевой балансировщик ***L4*** для ***tcp/udp***
2. Изучи какие алгоритмы балансировки бывают

---

## Запуск

&emsp; Сначала запускаем сервер [`srv.cpp`](https://github.com/t-chakir/chakir/blob/main/L4/srv/srv.cpp) через [`./srv.sh`](https://github.com/t-chakir/chakir/blob/main/L4/srv/srv.sh). Затем клиента [`client.cpp`](https://github.com/t-chakir/chakir/blob/main/L4/client/client.cpp) через [`./client.sh`](https://github.com/t-chakir/chakir/blob/main/L4/client/client.sh).


## Что такое алгоритмы балансировки нагрузки?

&emsp; *Алгоритмы балансировки нагрузки* — это стратегии распределения задач между несколькими серверами или ресурсами. Представьте, что у вас есть группа работников и много задач. Чтобы все были заняты и работа выполнялась эффективно, вы распределяете задачи равномерно, а не нагружаете одного человека. В вычислительных системах балансировка нагрузки делает то же самое.

Алгоритмы делятся на два типа:

- *Статические:* задачи распределяются заранее без учёта текущего состояния системы.
- *Динамические:* учитывают текущую нагрузку и состояние серверов в реальном времени.

## Статические алгоритмы балансировки нагрузки

&emsp; Статические алгоритмы распределяют задачи **по заранее заданным правилам**, не учитывая изменения в системе во время работы.

---

### 1. Циклический алгоритм (Round Robin)

**Описание:**

- Простой алгоритм, распределяющий запросы по серверам по очереди (циклически). Например, первый запрос идёт на сервер 1, второй — на сервер 2, третий — на сервер 3, затем снова на сервер 1 и так далее. Это похоже на раздачу конфет друзьям по кругу, чтобы каждому досталось поровну.

**Когда использовать:**

- Когда все серверы имеют одинаковую мощность.
- Для простых веб-запросов с равномерной нагрузкой.
- В системах, где порядок запросов не важен.

**Преимущества:**

- Простота реализации.
- Равномерное распределение нагрузки.

**Недостатки:**

- Не учитывает текущую нагрузку серверов.
- Не подходит, если серверы различаются по мощности.

---

### 2. Взвешенный циклический алгоритм (Weighted Round Robin)

**Описание:**

&emsp; Похож на циклический алгоритм, но каждому серверу присваивается вес (например, 0.3, 0.2, 0.1). Серверы с большим весом получают больше запросов. Это как раздача конфет, где одному другу, который больше любит сладости, дают больше конфет.

**Пример:**

- Если три сервера имеют веса 0.3, 0.2 и 0.1 (сумма = 0.6), то сервер 1 получит 50% запросов, сервер 2 — 33.33%, сервер 3 — 16.67%.

**Когда использовать:**

- Когда серверы имеют разную мощность (CPU, память и т.д.).
- Для оптимизации использования ресурсов серверо

**Преимущества:**

- Учитывает мощность серверов через веса.
- Гибкость в распределении нагрузки.

**Недостатки:**

- Более сложен, чем простой циклический алгоритм.
- Требует обновления весов при изменении мощности серверов.

---

### 3. Алгоритм хэширования по IP-адресу источника (Source IP Hash)

**Описание:**

&emsp; Этот алгоритм направляет запросы от одного и того же IP-адреса всегда на один и тот же сервер, используя хэш IP-адреса. Это обеспечивает постоянство сессии (например, пользователь всегда работает с одним сервером во время сеанса).

**Пример:**

- Это как запомнить, какой друг брал какую игрушку, и всегда давать ему ту же самую при следующем визите.

**Когда использовать:**

- Для приложений, требующих постоянства сессии (например, онлайн-банкинг).
- Когда пользователи из определённых регионов должны подключаться к конкретным серверам.

**Преимущества:**

- Постоянство: запросы от одного IP всегда идут на один сервер.
- Предсказуемость для сессий.

**Недостатки:**

- Неравномерное распределение, если некоторые IP-адреса генерируют больше трафика.
- Проблемы при добавлении/удалении серверов (может нарушить постоянство).

---

## Динамические алгоритмы балансировки нагрузки

Динамические алгоритмы принимают решения **в реальном времени**, учитывая **текущую нагрузку, состояние серверов или доступные ресурсы**.

---

### 1. Метод наименьшего количества соединений (Least Connection)

**Описание**:

- Направляет запросы на сервер с наименьшим количеством активных соединений, чтобы избежать перегрузки. Это как выбор качелей на площадке, где меньше всего детей.

**Когда использовать**:

- Для приложений с длительными запросами (например, потоковое видео).
- В системах с неравномерным трафиком.

**Преимущества**:

- Балансирует нагрузку в реальном времени.
- Адаптируется к текущему количеству соединений.

**Недостатки**:

- Не учитывает мощность серверов.
- Не подходит для приложений, требующих постоянства сессий.

---

### 2. Метод наименьшего времени ответа (Least Response Time)

**Описание**:

- Направляет запросы на сервер с наименьшим временем ответа, основываясь на исторических данных. Это как выбор самого быстрого повара в закусочной.

**Когда использовать**:

- Для приложений с высоким трафиком, где важна скорость ответа (например, интернет-магазины).
- Когда серверы имеют разную производительность.

**Преимущества**:

- Оптимизирует производительность системы.
- Адаптируется к изменениям в скорости ответа серверов.

**Недостатки**:

- Зависит от исторических данных, которые могут не отражать текущую ситуацию.
- Сложнее в реализации из-за необходимости отслеживания времени ответа.

---

### 3. Ресурсоориентированный алгоритм (Resource-Based)

**Описание**:

- Распределяет запросы на основе текущей доступности ресурсов сервера (например, загрузка CPU, память). Это как распределение задач в офисе, где вы даёте работу тому, кто сейчас менее занят.

**Когда использовать**:

- Для приложений с интенсивными задачами (например, обработка больших данных).
- Когда серверы имеют разную мощность, и нужно учитывать их ресурсы.

**Преимущества**:

- Оптимизирует использование ресурсов.
- Адаптируется к текущему состоянию серверов.

**Недостатки**:

- Сложность: требует постоянного мониторинга ресурсов.
- Дополнительная нагрузка на систему для отслеживания ресурсов.

---

### Итог

**Типы алгоритмов:**

- *Статические*: заранее задают, как распределять запросы (например, по очереди или по весам).
- *Динамические*: учитывают текущее состояние серверов (например, количество соединений или загрузку CPU).

**Примеры алгоритмов:**

- *Round Robin:* запросы идут по очереди на каждый сервер.
- *Weighted Round Robin:* серверы с большим «весом» (мощностью) получают больше запросов.
- *Source IP Hash:* запросы от одного IP всегда идут на один сервер.
- *Least Connection:* запросы идут на сервер с наименьшим числом активных соединений.
- *Least Response Time:* запросы идут на сервер с самым быстрым временем ответа.
- *Resource-Based:* запросы распределяются по доступным ресурсам сервера (CPU, память).

---

Информация была взята из источника [geeksforgeeks.org]( https://www.geeksforgeeks.org/load-balancing-algorithms/ )

---

## Сетевой балансировщик нагрузки L4

Для начала надо разобраться, что это такое балансировщик нагрузки и какие бывают.

Балансировщик нагрузки играет важную роль в распределение сетевого трафика между несколькими серверами для оптимизации.

### Виды балансироващиков

Бывают три вида балансироващика L4, L7 и GSLB

&emsp; Начнем с ***L4*** это балансировщики нагрузки 4-го уровня работают на транспортном уровне модели OSI. Является один из простых способов оптимизации, он способен не проверяя содержимое пакетных данных, распределять трафик на основое сетевой информации (например IP-адрес или номер порта).

&emsp; ***L7*** это балансировщики нагрузки 7-го уровня работают на прикладном уровне модели OSI. Он применает решение на основое содержимого, то есть распределять трафик в зависимости от твой информации,
которую ему предоставили.

&emsp; ***GSLB*** расшифровывается как **Global Server Load Balancer** в переводе *(глобальная балансировка нагрузки на сервер)*. Этот тип балансировщика нагрузки выходит за рамки традиционной локальной балансировки нагрузки и предназначен для распределения трафика между несколькими центрами обработки данных или географически распределенными серверами.

---

Подробную информацию можно взять из источника [geeksforgeeks.org]( https://www.geeksforgeeks.org/layer-4l4-layer-7l7-and-gslb-load-balancers/ )
